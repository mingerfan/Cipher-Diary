# 密码修改安全机制说明

## 问题背景

在加密日记应用中，修改密码需要重新加密所有数据。如果在重新加密过程中发生错误（如磁盘空间不足、权限问题、程序崩溃等），可能导致数据丢失或损坏。

## 安全机制设计

### 1. **两阶段提交策略**

密码修改过程分为两个阶段：

#### 阶段 1：准备和验证（在临时目录）
```
1. 验证旧密码是否正确
2. 生成新的 salt 和密钥
3. 创建临时备份目录 (.vault_backup_<uuid>)
4. 将所有数据用新密码加密并保存到临时目录
   - 重新加密所有日记条目
   - 重新加密所有图片附件
   - 生成新的元数据文件
5. 如果任何步骤失败：
   - 删除临时目录
   - 返回错误
   - **原数据完全未被修改**
```

#### 阶段 2：原子性替换
```
1. 将临时目录中的新加密文件复制到原位置
2. 替换元数据文件
3. 删除临时目录
4. 更新内存中的密钥状态
```

### 2. **安全保证**

#### ✅ 加密失败时的数据保护
- 所有新加密的数据都写入临时目录
- 原始数据文件在验证成功前不会被修改
- 任何加密错误都会触发回滚，删除临时文件

#### ✅ 原子性保证
- 先在临时位置完成所有加密操作
- 验证全部成功后才开始替换原文件
- 最小化原文件被修改的时间窗口

#### ⚠️ 已知限制
1. **替换阶段的失败**：如果在阶段 2 文件替换时失败，可能导致部分文件已被替换。此时：
   - 新密码的文件在临时目录中
   - 旧密码的文件可能部分被覆盖
   - 建议用户检查数据完整性

2. **磁盘空间要求**：临时目录需要存储所有数据的副本，因此需要大约 2 倍的数据存储空间

### 3. **错误处理流程**

```rust
// 伪代码示例
fn change_passphrase() -> Result<()> {
    // 阶段 1: 准备
    let result = {
        验证旧密码()?;
        创建临时目录()?;
        
        for each entry {
            备份原文件()?;
            用新密码加密到临时位置()?;
        }
        
        for each image {
            用新密码加密到临时位置()?;
        }
        
        保存新元数据到临时位置()?;
    };
    
    // 如果阶段 1 失败，原数据未被修改
    if result.is_err() {
        删除临时目录();
        return Err("密码修改失败，原数据未被修改");
    }
    
    // 阶段 2: 替换
    let replace_result = {
        for each entry {
            复制新文件到原位置()?;
        }
        替换元数据文件()?;
    };
    
    删除临时目录();
    
    // 如果阶段 2 失败，提示用户检查数据
    if replace_result.is_err() {
        return Err("文件替换失败，请检查数据完整性");
    }
    
    更新内存状态();
    Ok(())
}
```

### 4. **实现细节**

#### 文件备份
```rust
// 原文件路径: vault/entries/<uuid>.bin
// 临时路径: vault/.vault_backup_<uuid>/entries/<uuid>.bin
```

#### 图片重新加密
```rust
fn copy_and_reencrypt_images_recursive(
    src_dir: &Path,
    dst_dir: &Path,
    old_key: &[u8; 32],
    new_key: &[u8; 32],
) -> Result<()> {
    // 递归处理所有图片文件
    // 解密 -> 用新密钥加密 -> 保存到临时位置
}
```

#### 目录替换
```rust
fn replace_directory_contents(src_dir: &Path, dst_dir: &Path) -> Result<()> {
    // 1. 删除目标目录中的所有内容
    // 2. 复制源目录的所有内容到目标位置
}
```

### 5. **用户建议**

1. **修改密码前的准备**：
   - 确保有足够的磁盘空间（至少 2 倍数据大小）
   - 关闭其他可能占用文件的程序
   - 建议在网络良好的环境下进行（如果使用云同步）

2. **修改密码时**：
   - 不要强制关闭程序
   - 等待操作完成的提示
   - 注意错误消息

3. **如果出现错误**：
   - 如果提示"原数据未被修改"：可以安全地重试
   - 如果提示"请检查数据完整性"：请尝试用旧密码解锁，检查数据是否完整
   - 如果无法访问数据：检查是否有 `.vault_backup_*` 目录，其中可能包含新密码加密的数据

### 6. **未来改进方向**

1. **事务日志**：记录每一步操作，支持完整回滚
2. **增量替换**：使用原子文件重命名操作
3. **完整性校验**：在替换前后进行 CRC 或 hash 校验
4. **自动恢复**：检测上次未完成的密码修改操作并自动恢复

## 总结

当前实现通过两阶段提交策略，最大程度保护了用户数据：
- ✅ 阶段 1 失败：原数据 100% 安全
- ⚠️ 阶段 2 失败：大部分情况下数据可恢复，但需要手动检查

这是一个在实现复杂度和安全性之间的合理平衡。
